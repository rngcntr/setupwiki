{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SETUP WIKI This is a collection of various setup guides. Disk Encryption LUKS with passphrase LUKS with keyfile Raspberry Pi Setup for headless systems OpenVPN Server .Dotfiles Dotfile Setup Backup Borg Backup","title":"SETUP WIKI"},{"location":"#setup-wiki","text":"This is a collection of various setup guides.","title":"SETUP WIKI"},{"location":"#disk-encryption","text":"LUKS with passphrase LUKS with keyfile","title":"Disk Encryption"},{"location":"#raspberry-pi","text":"Setup for headless systems OpenVPN Server","title":"Raspberry Pi"},{"location":"#dotfiles","text":"Dotfile Setup","title":".Dotfiles"},{"location":"#backup","text":"Borg Backup","title":"Backup"},{"location":"Backup/borg/","text":"Borg Backup ( source ) Step-by-step guide to using borg as a tool for backups across multiple devices. I'll use a client-server approach where the server stores backups of multiple clients. Partition the physical drive and create a filesystem ( source ) Find the device name of your hard drive first using lsblk or parted -l . The name is in the format sdX where X is a lowercase letter. Create a new primary partition on this device using parted . When asked, confirm with Yes . # parted /dev/sdX/ (parted) mklabel gpt (parted) mkpart primary 1 -1 (parted) quit Use mkfs.ext4 to format the partition as ext4. Optionally, add a label by passing -L to the command. I use the label backup . # mkfs.ext4 -L backup /dev/sdX1 This process may take a little while. Verify it's success afterwards by checking lsblk --fs . Mounting the partition at boot time In order to mount the filesystem each time our server boots, edit the file /etc/fstab . In this case we add a line referencing the UUID found in lsblk --fs and mount it as ext4 to /mnt/backup . UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx /mnt/backup ext4 defaults 0 2 Now reboot or manually mount the filesystem. # /mnt/backup # mount -a Create a backup user and set it's home directory Add a user on the server who will have access to borg. Set the home directory to the backup partition. # useradd -m borg # passwd borg # usermod -d /mnt/backup/borg -m borg Allow ssh login as borg user On each client device, create a new ssh identity for borg and copy the public key to the server. ssh-keygen -t ed25519 ssh-copy-id -i \u00abpath/to/key\u00bb borg@\u00abserver\u00bb Restrict borg user access In case a single machine is compromised, an attacker will have acces to the borg server and will be able to delete all backups and control the server. To avoid this, we can restrict ssh access to only allow the borg command. Therefore, we log in as borg on our server and edit the file .ssh/authorized_keys . For each client, find the corresponding line and expand it by specifying command=\"...\" as seen below: command=\"borg serve --restrict-to-path ~/repo/\u00abclient\u00bb\" ssh-ed25519 \u00abkey_fingerprint\u00bb \u00abuser\u00bb@\u00abclient\u00bb Note that an attacker is still able to run borg prune and thereby delete existing backups. In order to avoid this, we can additionaly specify the --append-only flag. In this case we will not be able to run borg prune remotely anymore. To delete old backups, we will need physical access to the machine. command=\"borg serve --restrict-to-path ~/repo/\u00abclient\u00bb --append-only\" ssh-ed25519 \u00abkey_fingerprint\u00bb \u00abuser\u00bb@\u00abclient\u00bb Create a borg repository As borg on \u00abserver\u00bb : mkdir -p ~/repo/\u00abclient\u00bb On client: borg init --encryption=repokey borg@\u00abserver\u00bb:~/repo/\u00abclient\u00bb Export the repository key and store it in a safe location (e.g. password safe) borg key export borg@\u00abserver\u00bb:~/repo/\u00abclient\u00bb ./borg-key-\u00abclient\u00bb Backup a single file or directory # borg create -s --progress borg@\u00abserver\u00bb:~/repo/\u00abclient\u00bb::\u00abarchive\u00bb /path/to/file Backup an entire filesystem ( source ) Locations you want to exclude: /dev /lost+found /mnt /media /proc /run /sys /tmp # borg create --progress --verbose --stats --exclude-caches --exclude '/dev/*' \\ --exclude '/lost+found/*' \\ --exclude '/mnt/*' \\ --exclude '/media/*' \\ --exclude '/proc/*' \\ --exclude '/run/*' \\ --exclude '/sys/*' \\ --exclude '/tmp/*' \\ --exclude re:/\\\\.cache/ \\ --exclude re:/\\\\.ccache/ \\ borg@\u00abserver\u00bb:~/repo/\u00abclient\u00bb::\u00abclient\u00bb-\u00abdate\u00bb / Restore a backup Delete an archive # borg delete borg@\u00abserver\u00bb:~/repo/\u00abclient\u00bb::\u00abarchive\u00bb Delete old archives # borg prune --verbose --stats --progress --list \\ --keep-daily=14 \\ --keep-weekly=8 \\ --keep-monthly=12 \\ --keep-yearly=10 \\ borg@\u00abserver\u00bb:~/repo/\u00abclient\u00bb","title":"Borg Backup"},{"location":"Backup/borg/#borg-backup","text":"( source ) Step-by-step guide to using borg as a tool for backups across multiple devices. I'll use a client-server approach where the server stores backups of multiple clients.","title":"Borg Backup"},{"location":"Backup/borg/#partition-the-physical-drive-and-create-a-filesystem","text":"( source ) Find the device name of your hard drive first using lsblk or parted -l . The name is in the format sdX where X is a lowercase letter. Create a new primary partition on this device using parted . When asked, confirm with Yes . # parted /dev/sdX/ (parted) mklabel gpt (parted) mkpart primary 1 -1 (parted) quit Use mkfs.ext4 to format the partition as ext4. Optionally, add a label by passing -L to the command. I use the label backup . # mkfs.ext4 -L backup /dev/sdX1 This process may take a little while. Verify it's success afterwards by checking lsblk --fs .","title":"Partition the physical drive and create a filesystem"},{"location":"Backup/borg/#mounting-the-partition-at-boot-time","text":"In order to mount the filesystem each time our server boots, edit the file /etc/fstab . In this case we add a line referencing the UUID found in lsblk --fs and mount it as ext4 to /mnt/backup . UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx /mnt/backup ext4 defaults 0 2 Now reboot or manually mount the filesystem. # /mnt/backup # mount -a","title":"Mounting the partition at boot time"},{"location":"Backup/borg/#create-a-backup-user-and-set-its-home-directory","text":"Add a user on the server who will have access to borg. Set the home directory to the backup partition. # useradd -m borg # passwd borg # usermod -d /mnt/backup/borg -m borg","title":"Create a backup user and set it's home directory"},{"location":"Backup/borg/#allow-ssh-login-as-borg-user","text":"On each client device, create a new ssh identity for borg and copy the public key to the server. ssh-keygen -t ed25519 ssh-copy-id -i \u00abpath/to/key\u00bb borg@\u00abserver\u00bb","title":"Allow ssh login as borg user"},{"location":"Backup/borg/#restrict-borg-user-access","text":"In case a single machine is compromised, an attacker will have acces to the borg server and will be able to delete all backups and control the server. To avoid this, we can restrict ssh access to only allow the borg command. Therefore, we log in as borg on our server and edit the file .ssh/authorized_keys . For each client, find the corresponding line and expand it by specifying command=\"...\" as seen below: command=\"borg serve --restrict-to-path ~/repo/\u00abclient\u00bb\" ssh-ed25519 \u00abkey_fingerprint\u00bb \u00abuser\u00bb@\u00abclient\u00bb Note that an attacker is still able to run borg prune and thereby delete existing backups. In order to avoid this, we can additionaly specify the --append-only flag. In this case we will not be able to run borg prune remotely anymore. To delete old backups, we will need physical access to the machine. command=\"borg serve --restrict-to-path ~/repo/\u00abclient\u00bb --append-only\" ssh-ed25519 \u00abkey_fingerprint\u00bb \u00abuser\u00bb@\u00abclient\u00bb","title":"Restrict borg user access"},{"location":"Backup/borg/#create-a-borg-repository","text":"As borg on \u00abserver\u00bb : mkdir -p ~/repo/\u00abclient\u00bb On client: borg init --encryption=repokey borg@\u00abserver\u00bb:~/repo/\u00abclient\u00bb Export the repository key and store it in a safe location (e.g. password safe) borg key export borg@\u00abserver\u00bb:~/repo/\u00abclient\u00bb ./borg-key-\u00abclient\u00bb","title":"Create a borg repository"},{"location":"Backup/borg/#backup-a-single-file-or-directory","text":"# borg create -s --progress borg@\u00abserver\u00bb:~/repo/\u00abclient\u00bb::\u00abarchive\u00bb /path/to/file","title":"Backup a single file or directory"},{"location":"Backup/borg/#backup-an-entire-filesystem","text":"( source ) Locations you want to exclude: /dev /lost+found /mnt /media /proc /run /sys /tmp # borg create --progress --verbose --stats --exclude-caches --exclude '/dev/*' \\ --exclude '/lost+found/*' \\ --exclude '/mnt/*' \\ --exclude '/media/*' \\ --exclude '/proc/*' \\ --exclude '/run/*' \\ --exclude '/sys/*' \\ --exclude '/tmp/*' \\ --exclude re:/\\\\.cache/ \\ --exclude re:/\\\\.ccache/ \\ borg@\u00abserver\u00bb:~/repo/\u00abclient\u00bb::\u00abclient\u00bb-\u00abdate\u00bb /","title":"Backup an entire filesystem"},{"location":"Backup/borg/#restore-a-backup","text":"","title":"Restore a backup"},{"location":"Backup/borg/#delete-an-archive","text":"# borg delete borg@\u00abserver\u00bb:~/repo/\u00abclient\u00bb::\u00abarchive\u00bb","title":"Delete an archive"},{"location":"Backup/borg/#delete-old-archives","text":"# borg prune --verbose --stats --progress --list \\ --keep-daily=14 \\ --keep-weekly=8 \\ --keep-monthly=12 \\ --keep-yearly=10 \\ borg@\u00abserver\u00bb:~/repo/\u00abclient\u00bb","title":"Delete old archives"},{"location":"Dotfiles/setup/","text":"Dotfiles","title":"Dotfiles"},{"location":"Dotfiles/setup/#dotfiles","text":"","title":"Dotfiles"},{"location":"Full_Disk_Encryption/luks_crypt_keyfile/","text":"LUKS Crypt ( source ) In this guide, I'm going to setup a keyfile-encrypted LUKS partition. I will be using a single, max-size partition on a single physical device. The mountpoint can be determined by running lsblk . Partition the physical device parted /dev/sdX (parted) mklabel gpt (parted) mkpart primary 1 -1 (parted) quit Create the key file Before we go further, let's create our 2048-bit key file first. I'm going to install it /root/backup.key sudo dd if=/dev/urandom of=/root/backup.key bs=1024 count=2 sudo chmod 0400 /root/backup.key Create LUKS partition In my case, /dev/sdX1 was created by parted . Create the LUKS partition with our key file now. cryptsetup luksFormat /dev/sdX1 /root/backup.key Associating our key with the LUKS partition will allow us to automount it later and prevent us from ever seeing a password prompt. cryptsetup luksAddKey /dev/sdX1 /root/backup.key --key-file=/root/backup.key Initialize the LUKS partition Before we can start using our LUKS partition, we have to size it properly and format it first. In order to do that, we will first use luksOpen which creates an IO backing device that allows us to interact with the partition. I'll call my device backup ; you can call yours whatever you want. cryptsetup luksOpen /dev/sdX1 backup --key-file=/root/backup.key the LUKS mapping device will now be available at /dev/mapper/backup Size the LUKS partition When using resize without any additional vars, it will use the max size of the underlying partition. cryptsetup resize backup Format the LUKS partition I'm going to use ext4 ; you can use whatever you want. mkfs.ext4 /dev/mapper/backup Create a mount point I'll create a mount point at /backup sudo mkdir -p /backup sudo chmod 755 /backup Mount the LUKS mapping device mount /dev/mapper/backup /backup df /backup Automountable To avoid the hassle of mounting are encrypted volume manually, we can set it up such that it automounts using the specified key file. First you have to get the UUID for your partition. ls -l /dev/disk/by-uuid Find the UUID that links to your disk. In my case, it is 651322a-8171-49b4-9707-a96698ec826e . export UUID=\"651322a-8171-49b4-9707-a96698ec826e\" sudo echo \"backup UUID=${UUID} /root/backup.key luks\" >> /etc/crypttab Finally, specify the automount sudo echo \"/dev/mapper/backup /backup auto\" >> /etc/fstab Mount stuff! sudo mount -a","title":"Luks crypt keyfile"},{"location":"Full_Disk_Encryption/luks_crypt_keyfile/#luks-crypt","text":"( source ) In this guide, I'm going to setup a keyfile-encrypted LUKS partition. I will be using a single, max-size partition on a single physical device. The mountpoint can be determined by running lsblk .","title":"LUKS Crypt"},{"location":"Full_Disk_Encryption/luks_crypt_keyfile/#partition-the-physical-device","text":"parted /dev/sdX (parted) mklabel gpt (parted) mkpart primary 1 -1 (parted) quit","title":"Partition the physical device"},{"location":"Full_Disk_Encryption/luks_crypt_keyfile/#create-the-key-file","text":"Before we go further, let's create our 2048-bit key file first. I'm going to install it /root/backup.key sudo dd if=/dev/urandom of=/root/backup.key bs=1024 count=2 sudo chmod 0400 /root/backup.key","title":"Create the key file"},{"location":"Full_Disk_Encryption/luks_crypt_keyfile/#create-luks-partition","text":"In my case, /dev/sdX1 was created by parted . Create the LUKS partition with our key file now. cryptsetup luksFormat /dev/sdX1 /root/backup.key Associating our key with the LUKS partition will allow us to automount it later and prevent us from ever seeing a password prompt. cryptsetup luksAddKey /dev/sdX1 /root/backup.key --key-file=/root/backup.key","title":"Create LUKS partition"},{"location":"Full_Disk_Encryption/luks_crypt_keyfile/#initialize-the-luks-partition","text":"Before we can start using our LUKS partition, we have to size it properly and format it first. In order to do that, we will first use luksOpen which creates an IO backing device that allows us to interact with the partition. I'll call my device backup ; you can call yours whatever you want. cryptsetup luksOpen /dev/sdX1 backup --key-file=/root/backup.key the LUKS mapping device will now be available at /dev/mapper/backup","title":"Initialize the LUKS partition"},{"location":"Full_Disk_Encryption/luks_crypt_keyfile/#size-the-luks-partition","text":"When using resize without any additional vars, it will use the max size of the underlying partition. cryptsetup resize backup","title":"Size the LUKS partition"},{"location":"Full_Disk_Encryption/luks_crypt_keyfile/#format-the-luks-partition","text":"I'm going to use ext4 ; you can use whatever you want. mkfs.ext4 /dev/mapper/backup","title":"Format the LUKS partition"},{"location":"Full_Disk_Encryption/luks_crypt_keyfile/#create-a-mount-point","text":"I'll create a mount point at /backup sudo mkdir -p /backup sudo chmod 755 /backup","title":"Create a mount point"},{"location":"Full_Disk_Encryption/luks_crypt_keyfile/#mount-the-luks-mapping-device","text":"mount /dev/mapper/backup /backup df /backup","title":"Mount the LUKS mapping device"},{"location":"Full_Disk_Encryption/luks_crypt_keyfile/#automountable","text":"To avoid the hassle of mounting are encrypted volume manually, we can set it up such that it automounts using the specified key file. First you have to get the UUID for your partition. ls -l /dev/disk/by-uuid Find the UUID that links to your disk. In my case, it is 651322a-8171-49b4-9707-a96698ec826e . export UUID=\"651322a-8171-49b4-9707-a96698ec826e\" sudo echo \"backup UUID=${UUID} /root/backup.key luks\" >> /etc/crypttab Finally, specify the automount sudo echo \"/dev/mapper/backup /backup auto\" >> /etc/fstab Mount stuff! sudo mount -a","title":"Automountable"},{"location":"Full_Disk_Encryption/luks_crypt_password/","text":"LUKS Crypt ( source ) In this guide, I'm going to setup a keyfile-encrypted LUKS partition. I will be using a single, max-size partition on a single physical device. The mountpoint can be determined by running lsblk . Partition the physical device sudo parted /dev/sdX (parted) mklabel gpt (parted) mkpart primary 1 -1 (parted) quit Create LUKS partition In my case, /dev/sdX1 was created by parted . Create the LUKS partition with our key file now. sudo cryptsetup luksFormat --type luks2 /dev/sdX1 Access the LUKS partition To gain access to the encrypted partition, unlock it with the device mapper, using: sudo cryptsetup open /dev/sdX1 backup Size the LUKS partition When using resize without any additional vars, it will use the max size of the underlying partition. sudo cryptsetup resize backup Format the LUKS partition I'm going to use ext4 ; you can use whatever you want. sudo mkfs.ext4 /dev/mapper/backup Create a mount point I'll create a mount point at /backup sudo mkdir -p /backup sudo chmod 755 /backup Mount the LUKS mapping device sudo cryptsetup open /dev/sdX1 backup sudo mount /dev/mapper/backup /backup To check the status, use: df /backup Unmount the LUKS mapping device sudo unmount /backup cryptsetup close backup Automountable To avoid the hassle of mounting are encrypted volume manually, we can set it up such that it automounts using the specified key file. First you have to get the UUID for your partition. ls -l /dev/disk/by-uuid Find the UUID that links to your disk. In my case, it is 651322a-8171-49b4-9707-a96698ec826e . export UUID=\"651322a-8171-49b4-9707-a96698ec826e\" sudo echo \"backup UUID=${UUID} none luks,timeout=180\" >> /etc/crypttab Finally, specify the automount sudo echo \"/dev/mapper/backup /backup auto defaults,errors=remount-ro 0 2\" >> /etc/fstab Mount stuff! sudo mount -a","title":"LUKS Crypt"},{"location":"Full_Disk_Encryption/luks_crypt_password/#luks-crypt","text":"( source ) In this guide, I'm going to setup a keyfile-encrypted LUKS partition. I will be using a single, max-size partition on a single physical device. The mountpoint can be determined by running lsblk .","title":"LUKS Crypt"},{"location":"Full_Disk_Encryption/luks_crypt_password/#partition-the-physical-device","text":"sudo parted /dev/sdX (parted) mklabel gpt (parted) mkpart primary 1 -1 (parted) quit","title":"Partition the physical device"},{"location":"Full_Disk_Encryption/luks_crypt_password/#create-luks-partition","text":"In my case, /dev/sdX1 was created by parted . Create the LUKS partition with our key file now. sudo cryptsetup luksFormat --type luks2 /dev/sdX1","title":"Create LUKS partition"},{"location":"Full_Disk_Encryption/luks_crypt_password/#access-the-luks-partition","text":"To gain access to the encrypted partition, unlock it with the device mapper, using: sudo cryptsetup open /dev/sdX1 backup","title":"Access the LUKS partition"},{"location":"Full_Disk_Encryption/luks_crypt_password/#size-the-luks-partition","text":"When using resize without any additional vars, it will use the max size of the underlying partition. sudo cryptsetup resize backup","title":"Size the LUKS partition"},{"location":"Full_Disk_Encryption/luks_crypt_password/#format-the-luks-partition","text":"I'm going to use ext4 ; you can use whatever you want. sudo mkfs.ext4 /dev/mapper/backup","title":"Format the LUKS partition"},{"location":"Full_Disk_Encryption/luks_crypt_password/#create-a-mount-point","text":"I'll create a mount point at /backup sudo mkdir -p /backup sudo chmod 755 /backup","title":"Create a mount point"},{"location":"Full_Disk_Encryption/luks_crypt_password/#mount-the-luks-mapping-device","text":"sudo cryptsetup open /dev/sdX1 backup sudo mount /dev/mapper/backup /backup To check the status, use: df /backup","title":"Mount the LUKS mapping device"},{"location":"Full_Disk_Encryption/luks_crypt_password/#unmount-the-luks-mapping-device","text":"sudo unmount /backup cryptsetup close backup","title":"Unmount the LUKS mapping device"},{"location":"Full_Disk_Encryption/luks_crypt_password/#automountable","text":"To avoid the hassle of mounting are encrypted volume manually, we can set it up such that it automounts using the specified key file. First you have to get the UUID for your partition. ls -l /dev/disk/by-uuid Find the UUID that links to your disk. In my case, it is 651322a-8171-49b4-9707-a96698ec826e . export UUID=\"651322a-8171-49b4-9707-a96698ec826e\" sudo echo \"backup UUID=${UUID} none luks,timeout=180\" >> /etc/crypttab Finally, specify the automount sudo echo \"/dev/mapper/backup /backup auto defaults,errors=remount-ro 0 2\" >> /etc/fstab Mount stuff! sudo mount -a","title":"Automountable"},{"location":"Raspberry_Pi/openvpn/","text":"OpenVPN on a Raspberry Pi ( source ) Create an openvpn user To avoid conflicts with other users, create a new user for the VPN service and set a password for this user. In my case the user is called \u00abopenvpn\u00bb. # adduser \u00abopenvpn\u00bb # passwd \u00abopenvpn\u00bb # sudo usermod -a -G sudo \u00abopenvpn\u00bb # mkdir /home/\u00abopenvpn\u00bb # chown /home/openvpn \u00abopenvpn\u00bb # chgrp /home/openvpn \u00abopenvpn\u00bb Log in as \u00abopenvpn\u00bb. su - \u00abopenvpn\u00bb Run the PiVPN install script curl -L install.pivpn.io > pivpn.sh chmod +x pivpn.sh Once you are sure the script is not harmful in any way, run the installation script. # ./pivpn.sh Confirm the current network settings and make sure the shown IP address (eg. 192.168.2.110) is always assigned to this device by the router. Choose the user \u00abopenvpn\u00bb. When asked, select UDP as a protocol. Confirm the default OpenVPN port 1194. Select ECDSA encryption strength. (Recommended: 256-bit) If you use DNS, enter the domain name. Reboot after the installation has finished Add clients To generate a client configuration, use: pivpn add Select a different username and password for each client. Copy the resulting ovpn file to your client device via scp and use it in your OpenVPN client.","title":"OpenVPN on a Raspberry Pi"},{"location":"Raspberry_Pi/openvpn/#openvpn-on-a-raspberry-pi","text":"( source )","title":"OpenVPN on a Raspberry Pi"},{"location":"Raspberry_Pi/openvpn/#create-an-openvpn-user","text":"To avoid conflicts with other users, create a new user for the VPN service and set a password for this user. In my case the user is called \u00abopenvpn\u00bb. # adduser \u00abopenvpn\u00bb # passwd \u00abopenvpn\u00bb # sudo usermod -a -G sudo \u00abopenvpn\u00bb # mkdir /home/\u00abopenvpn\u00bb # chown /home/openvpn \u00abopenvpn\u00bb # chgrp /home/openvpn \u00abopenvpn\u00bb Log in as \u00abopenvpn\u00bb. su - \u00abopenvpn\u00bb","title":"Create an openvpn user"},{"location":"Raspberry_Pi/openvpn/#run-the-pivpn-install-script","text":"curl -L install.pivpn.io > pivpn.sh chmod +x pivpn.sh Once you are sure the script is not harmful in any way, run the installation script. # ./pivpn.sh Confirm the current network settings and make sure the shown IP address (eg. 192.168.2.110) is always assigned to this device by the router. Choose the user \u00abopenvpn\u00bb. When asked, select UDP as a protocol. Confirm the default OpenVPN port 1194. Select ECDSA encryption strength. (Recommended: 256-bit) If you use DNS, enter the domain name. Reboot after the installation has finished","title":"Run the PiVPN install script"},{"location":"Raspberry_Pi/openvpn/#add-clients","text":"To generate a client configuration, use: pivpn add Select a different username and password for each client. Copy the resulting ovpn file to your client device via scp and use it in your OpenVPN client.","title":"Add clients"},{"location":"Raspberry_Pi/setup_sdcard_headless/","text":"Raspberry Pi Setup Guide ( source ) This guide describes the installation of Raspbian on a Raspberry Pi 3B+ as a headless server. Download Raspbian Image The latest Raspbian image can be downloaded from https://www.raspberrypi.org/downloads/raspbian/. In this case no desktop environment is needed so we use Raspbian Stretch Lite . Extract the zip file by running the following command with adjusted date: unzip 2018-11-13-raspbian-stretch-lite.zip rm 2018-11-13-raspbian-stretch-lite.zip Write the image to the SD card Run lsblk before and after inserting the SD card into the SD card reader in order to determine the NAME of the SD card. The device should be listed as sdX where X is a lower-case letter indicating the device. If any partitions on the SD card are currently mounted (check the rightmost column of lsblk ), unmount all of them. umount /dev/sdX1 Write the image to the SD card with dd . if= specifies the image as the source file and of= specifies the SD card as the destination. Make sure to use the correct device to avoid data loss. The destination is specified by device name, not by partition name. # dd bs=4M if=2018-11-13-raspbian-stretch-lite.img of=/dev/sdX status=progress conv=fsync If any errors occur, try block size 1M instead of 4M Optional: Checking whether the image was written correctly The output of the dd command shows a number of written records ( xxx+0 records in ). Use this record count to copy the image back from the SD card to your local drive. # dd bs=4M if=/dev/sdX of=from-sd-card.img status=progress count=xxx Truncate the new image to the size of the original image and compare the new image with the original one. # truncate --reference 2018-11-13-raspbian-stretch-lite.img from-sd-card.img diff -s from-sd-card.img 2018-11-13-raspbian-stretch-lite.img Eject the SD card Flush the write cache. sync Remove the SD card from the card reader. Enable ssh for headless systems Insert the SD card into the card reader. It will be mounted by defalt. Navigate to the boot partition of the SD card and create an empty file named ssh . The mountpoint of the boot partition can be determined via lsblk . cd /run/media/$USER/boot touch ssh Enable WIFI for headless systems ( source ) Insert the SD card into the card reader. It will be mounted by defalt. Navigate to the boot partition of the SD card. The mountpoint of the boot partition can be determined via lsblk . cd /run/media/$USER/boot Create a file named wpa_supplicant.conf with the following content: ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 country=\u00abyour_ISO-3166-1_two-letter_country_code\u00bb network={ ssid=\"\u00abyour_SSID\u00bb\" psk=\"\u00abyour_PSK\u00bb\" key_mgmt=WPA-PSK } Replace \u00abyour_ISO-3166-1_two-letter_country_code\u00bb with your ISO Country Code , \u00abyour_SSID\u00bb with the SSID of your network and \u00abyour_PSK\u00bb with the corresponding wifi password. Connect to the Raspberry Pi ( source ) Establish an ssh connection to the Raspberry Pi with default credentials: User: pi Password: raspberry ssh pi@raspberrypi If this does not initialize a connection, find out the IP either by running nmap -p 22 \u00absubnet mask\u00bb on your local subnet or finding the device in the router's DHCP table. You can now change the host name if you want. Replace raspberrypi by the new name in the following two files and reboot. # vim /etc/hostname # vim /etc/hosts # reboot Remove the message of the day # echo \"\" > /etc/motd Secure login and permissions If needed, configure the Raspberry Pi via the configuration script. # raspi-config Change the default root password. # passwd root Now create a new user for ssh access and allow sudo access for the new account. Don't remove sudo access for pi immediately. You can remove it once you have tested sudo with the new user account. # adduser \u00abuser\u00bb # usermod -a -G sudo \u00abuser\u00bb If you have sudo access with your new account, remove the default user pi. # deluser -remove-home pi For further ssh setup instructions visit Securing SSH Guide","title":"Raspberry Pi Setup Guide"},{"location":"Raspberry_Pi/setup_sdcard_headless/#raspberry-pi-setup-guide","text":"( source ) This guide describes the installation of Raspbian on a Raspberry Pi 3B+ as a headless server.","title":"Raspberry Pi Setup Guide"},{"location":"Raspberry_Pi/setup_sdcard_headless/#download-raspbian-image","text":"The latest Raspbian image can be downloaded from https://www.raspberrypi.org/downloads/raspbian/. In this case no desktop environment is needed so we use Raspbian Stretch Lite . Extract the zip file by running the following command with adjusted date: unzip 2018-11-13-raspbian-stretch-lite.zip rm 2018-11-13-raspbian-stretch-lite.zip","title":"Download Raspbian Image"},{"location":"Raspberry_Pi/setup_sdcard_headless/#write-the-image-to-the-sd-card","text":"Run lsblk before and after inserting the SD card into the SD card reader in order to determine the NAME of the SD card. The device should be listed as sdX where X is a lower-case letter indicating the device. If any partitions on the SD card are currently mounted (check the rightmost column of lsblk ), unmount all of them. umount /dev/sdX1 Write the image to the SD card with dd . if= specifies the image as the source file and of= specifies the SD card as the destination. Make sure to use the correct device to avoid data loss. The destination is specified by device name, not by partition name. # dd bs=4M if=2018-11-13-raspbian-stretch-lite.img of=/dev/sdX status=progress conv=fsync If any errors occur, try block size 1M instead of 4M","title":"Write the image to the SD card"},{"location":"Raspberry_Pi/setup_sdcard_headless/#optional-checking-whether-the-image-was-written-correctly","text":"The output of the dd command shows a number of written records ( xxx+0 records in ). Use this record count to copy the image back from the SD card to your local drive. # dd bs=4M if=/dev/sdX of=from-sd-card.img status=progress count=xxx Truncate the new image to the size of the original image and compare the new image with the original one. # truncate --reference 2018-11-13-raspbian-stretch-lite.img from-sd-card.img diff -s from-sd-card.img 2018-11-13-raspbian-stretch-lite.img","title":"Optional: Checking whether the image was written correctly"},{"location":"Raspberry_Pi/setup_sdcard_headless/#eject-the-sd-card","text":"Flush the write cache. sync Remove the SD card from the card reader.","title":"Eject the SD card"},{"location":"Raspberry_Pi/setup_sdcard_headless/#enable-ssh-for-headless-systems","text":"Insert the SD card into the card reader. It will be mounted by defalt. Navigate to the boot partition of the SD card and create an empty file named ssh . The mountpoint of the boot partition can be determined via lsblk . cd /run/media/$USER/boot touch ssh","title":"Enable ssh for headless systems"},{"location":"Raspberry_Pi/setup_sdcard_headless/#enable-wifi-for-headless-systems","text":"( source ) Insert the SD card into the card reader. It will be mounted by defalt. Navigate to the boot partition of the SD card. The mountpoint of the boot partition can be determined via lsblk . cd /run/media/$USER/boot Create a file named wpa_supplicant.conf with the following content: ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 country=\u00abyour_ISO-3166-1_two-letter_country_code\u00bb network={ ssid=\"\u00abyour_SSID\u00bb\" psk=\"\u00abyour_PSK\u00bb\" key_mgmt=WPA-PSK } Replace \u00abyour_ISO-3166-1_two-letter_country_code\u00bb with your ISO Country Code , \u00abyour_SSID\u00bb with the SSID of your network and \u00abyour_PSK\u00bb with the corresponding wifi password.","title":"Enable WIFI for headless systems"},{"location":"Raspberry_Pi/setup_sdcard_headless/#connect-to-the-raspberry-pi","text":"( source ) Establish an ssh connection to the Raspberry Pi with default credentials: User: pi Password: raspberry ssh pi@raspberrypi If this does not initialize a connection, find out the IP either by running nmap -p 22 \u00absubnet mask\u00bb on your local subnet or finding the device in the router's DHCP table. You can now change the host name if you want. Replace raspberrypi by the new name in the following two files and reboot. # vim /etc/hostname # vim /etc/hosts # reboot Remove the message of the day # echo \"\" > /etc/motd","title":"Connect to the Raspberry Pi"},{"location":"Raspberry_Pi/setup_sdcard_headless/#secure-login-and-permissions","text":"If needed, configure the Raspberry Pi via the configuration script. # raspi-config Change the default root password. # passwd root Now create a new user for ssh access and allow sudo access for the new account. Don't remove sudo access for pi immediately. You can remove it once you have tested sudo with the new user account. # adduser \u00abuser\u00bb # usermod -a -G sudo \u00abuser\u00bb If you have sudo access with your new account, remove the default user pi. # deluser -remove-home pi For further ssh setup instructions visit Securing SSH Guide","title":"Secure login and permissions"},{"location":"SSH/secure_setup/","text":"Secure SSH setup Use key-based login Copy your public key from the client machine to the server. Run the following command on the client: ssh-copy-id -i ~/.ssh/my_key user@server","title":"Secure SSH setup"},{"location":"SSH/secure_setup/#secure-ssh-setup","text":"","title":"Secure SSH setup"},{"location":"SSH/secure_setup/#use-key-based-login","text":"Copy your public key from the client machine to the server. Run the following command on the client: ssh-copy-id -i ~/.ssh/my_key user@server","title":"Use key-based login"},{"location":"SSH/secure_ssh/","text":"TODO ssh-copy-id -i ~/.ssh/\u00abkey\u00bb \u00abuser\u00bb@\u00abhostname\u00bb /etc/ssh/sshd_config PasswordAuthentication no ChallengeResponseAuthentication no UsePAM no # service ssh restart","title":"TODO"},{"location":"SSH/secure_ssh/#todo","text":"ssh-copy-id -i ~/.ssh/\u00abkey\u00bb \u00abuser\u00bb@\u00abhostname\u00bb /etc/ssh/sshd_config PasswordAuthentication no ChallengeResponseAuthentication no UsePAM no # service ssh restart","title":"TODO"}]}