{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Setup Wiki \u00b6 This is a collection of various setup guides. All instructions are based on my own experience or the experience of others and on procedures that have worked well on my own system. I try to keep the instructions general and as independent of the system as possible. None of the entries claims completeness or functionality. Backup \u00b6 Borg Backup Raspberry Pi \u00b6 Setup for headless systems OpenVPN Server Troubleshooting \u00b6 Arduino Manjaro Miscellaneous \u00b6 Dotfiles LUKS Disk Encryption","title":"Main Page"},{"location":"index.html#setup-wiki","text":"This is a collection of various setup guides. All instructions are based on my own experience or the experience of others and on procedures that have worked well on my own system. I try to keep the instructions general and as independent of the system as possible. None of the entries claims completeness or functionality.","title":"Setup Wiki"},{"location":"index.html#backup","text":"Borg Backup","title":"Backup"},{"location":"index.html#raspberry-pi","text":"Setup for headless systems OpenVPN Server","title":"Raspberry Pi"},{"location":"index.html#troubleshooting","text":"Arduino Manjaro","title":"Troubleshooting"},{"location":"index.html#miscellaneous","text":"Dotfiles LUKS Disk Encryption","title":"Miscellaneous"},{"location":"google965318b363cc9579.html","text":"","title":"Google965318b363cc9579"},{"location":"Backup/Borg.html","text":"Borg Backup \u00b6 Source: borgbackup.readthedocs.io Step-by-step guide to using borg as a tool for backups across multiple devices. I'll use a client-server approach where the server stores backups of multiple clients. Partition the physical drive and create a filesystem \u00b6 Source: www.digitalocean.com Find the device name of your hard drive first using lsblk or parted -l . The name is in the format sdX where X is a lowercase letter. Create a new primary partition on this device using parted . When asked, confirm with Yes . 1 2 3 4 # parted /dev/sdX/ (parted) mklabel gpt (parted) mkpart primary 1 -1 (parted) quit Use mkfs.ext4 to format the partition as ext4. Optionally, add a label by passing -L to the command. I use the label backup . 1 # mkfs.ext4 -L backup /dev/sdX1 This process may take a little while. Verify it's success afterwards by checking lsblk --fs . Mounting the partition at boot time \u00b6 In order to mount the filesystem each time our server boots, edit the file /etc/fstab . In this case we add a line referencing the UUID found in lsblk --fs and mount it as ext4 to /mnt/backup . 1 UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx /mnt/backup ext4 defaults 0 2 Now reboot or manually mount the filesystem. 1 2 # /mnt/backup # mount -a Create a backup user and set it's home directory \u00b6 Add a user on the server who will have access to borg. Set the home directory to the backup partition. 1 2 3 # useradd -m borg # passwd borg # usermod -d /mnt/backup/borg -m borg Allow ssh login as borg user \u00b6 On each client device, create a new ssh identity for borg and copy the public key to the server. 1 2 $ ssh-keygen -t ed25519 $ ssh-copy-id -i \u00abpath/to/key\u00bb borg@\u00abserver\u00bb Restrict borg user access \u00b6 In case a single machine is compromised, an attacker will have acces to the borg server and will be able to delete all backups and control the server. To avoid this, we can restrict ssh access to only allow the borg command. Therefore, we log in as borg on our server and edit the file .ssh / authorized_keys . For each client, find the corresponding line and expand it by specifying command=\"...\" as seen below: 1 command=\"borg serve --restrict-to-path ~/repo/\u00abclient\u00bb\" ssh-ed25519 \u00abkey_fingerprint\u00bb \u00abuser\u00bb@\u00abclient\u00bb Note that an attacker is still able to run borg prune and thereby delete existing backups. In order to avoid this, we can additionaly specify the --append-only flag. In this case we will not be able to run borg prune remotely anymore. To delete old backups, we will need physical access to the machine. 1 command=\"borg serve --restrict-to-path ~/repo/\u00abclient\u00bb --append-only\" ssh-ed25519 \u00abkey_fingerprint\u00bb \u00abuser\u00bb@\u00abclient\u00bb Finally, we can now disable normal login for the user borg. 1 # passwd -l borg Login as borg via root After doing this, we will still be able to log into our borg account by running su - borg as root. 1 # su - borg Create a borg repository \u00b6 As borg on \u00abserver\u00bb : 1 $ mkdir -p ~/repo/\u00abclient\u00bb On client: 1 $ borg init --encryption = repokey borg@\u00abserver\u00bb:~/repo/\u00abclient\u00bb Export the repository key and store it in a safe location (e.g. password safe) 1 $ borg key export borg@\u00abserver\u00bb:~/repo/\u00abclient\u00bb ./borg-key-\u00abclient\u00bb Backup a single file or directory \u00b6 1 # borg create -s --progress borg@\u00abserver\u00bb:~/repo/\u00abclient\u00bb::\u00abarchive\u00bb /path/to/file Backup an entire filesystem \u00b6 Source: thomas-leistner.de Locations you want to exclude: 1 2 3 4 5 6 7 8 /dev /lost+found /mnt /media /proc /run /sys /tmp 1 2 3 4 5 6 7 8 9 10 11 # borg create --progress --verbose --stats --exclude-caches --exclude '/dev/*' \\ --exclude '/lost+found/*' \\ --exclude '/mnt/*' \\ --exclude '/media/*' \\ --exclude '/proc/*' \\ --exclude '/run/*' \\ --exclude '/sys/*' \\ --exclude '/tmp/*' \\ --exclude re:/ \\\\ .cache/ \\ --exclude re:/ \\\\ .ccache/ \\ borg@\u00abserver\u00bb:~/repo/\u00abclient\u00bb::\u00abclient\u00bb-\u00abdate\u00bb / Restore a backup \u00b6 Delete an archive \u00b6 1 # borg delete borg@\u00abserver\u00bb:~/repo/\u00abclient\u00bb::\u00abarchive\u00bb Delete old archives \u00b6 1 2 3 4 5 6 # borg prune --verbose --stats --progress --list \\ --keep-daily = 14 \\ --keep-weekly = 8 \\ --keep-monthly = 12 \\ --keep-yearly = 10 \\ borg@\u00abserver\u00bb:~/repo/\u00abclient\u00bb Automating daily backup \u00b6 Source: www.thomas-krenn.com","title":"Borg"},{"location":"Backup/Borg.html#borg-backup","text":"Source: borgbackup.readthedocs.io Step-by-step guide to using borg as a tool for backups across multiple devices. I'll use a client-server approach where the server stores backups of multiple clients.","title":"Borg Backup"},{"location":"Backup/Borg.html#partition-the-physical-drive-and-create-a-filesystem","text":"Source: www.digitalocean.com Find the device name of your hard drive first using lsblk or parted -l . The name is in the format sdX where X is a lowercase letter. Create a new primary partition on this device using parted . When asked, confirm with Yes . 1 2 3 4 # parted /dev/sdX/ (parted) mklabel gpt (parted) mkpart primary 1 -1 (parted) quit Use mkfs.ext4 to format the partition as ext4. Optionally, add a label by passing -L to the command. I use the label backup . 1 # mkfs.ext4 -L backup /dev/sdX1 This process may take a little while. Verify it's success afterwards by checking lsblk --fs .","title":"Partition the physical drive and create a filesystem"},{"location":"Backup/Borg.html#mounting-the-partition-at-boot-time","text":"In order to mount the filesystem each time our server boots, edit the file /etc/fstab . In this case we add a line referencing the UUID found in lsblk --fs and mount it as ext4 to /mnt/backup . 1 UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx /mnt/backup ext4 defaults 0 2 Now reboot or manually mount the filesystem. 1 2 # /mnt/backup # mount -a","title":"Mounting the partition at boot time"},{"location":"Backup/Borg.html#create-a-backup-user-and-set-its-home-directory","text":"Add a user on the server who will have access to borg. Set the home directory to the backup partition. 1 2 3 # useradd -m borg # passwd borg # usermod -d /mnt/backup/borg -m borg","title":"Create a backup user and set it's home directory"},{"location":"Backup/Borg.html#allow-ssh-login-as-borg-user","text":"On each client device, create a new ssh identity for borg and copy the public key to the server. 1 2 $ ssh-keygen -t ed25519 $ ssh-copy-id -i \u00abpath/to/key\u00bb borg@\u00abserver\u00bb","title":"Allow ssh login as borg user"},{"location":"Backup/Borg.html#restrict-borg-user-access","text":"In case a single machine is compromised, an attacker will have acces to the borg server and will be able to delete all backups and control the server. To avoid this, we can restrict ssh access to only allow the borg command. Therefore, we log in as borg on our server and edit the file .ssh / authorized_keys . For each client, find the corresponding line and expand it by specifying command=\"...\" as seen below: 1 command=\"borg serve --restrict-to-path ~/repo/\u00abclient\u00bb\" ssh-ed25519 \u00abkey_fingerprint\u00bb \u00abuser\u00bb@\u00abclient\u00bb Note that an attacker is still able to run borg prune and thereby delete existing backups. In order to avoid this, we can additionaly specify the --append-only flag. In this case we will not be able to run borg prune remotely anymore. To delete old backups, we will need physical access to the machine. 1 command=\"borg serve --restrict-to-path ~/repo/\u00abclient\u00bb --append-only\" ssh-ed25519 \u00abkey_fingerprint\u00bb \u00abuser\u00bb@\u00abclient\u00bb Finally, we can now disable normal login for the user borg. 1 # passwd -l borg Login as borg via root After doing this, we will still be able to log into our borg account by running su - borg as root. 1 # su - borg","title":"Restrict borg user access"},{"location":"Backup/Borg.html#create-a-borg-repository","text":"As borg on \u00abserver\u00bb : 1 $ mkdir -p ~/repo/\u00abclient\u00bb On client: 1 $ borg init --encryption = repokey borg@\u00abserver\u00bb:~/repo/\u00abclient\u00bb Export the repository key and store it in a safe location (e.g. password safe) 1 $ borg key export borg@\u00abserver\u00bb:~/repo/\u00abclient\u00bb ./borg-key-\u00abclient\u00bb","title":"Create a borg repository"},{"location":"Backup/Borg.html#backup-a-single-file-or-directory","text":"1 # borg create -s --progress borg@\u00abserver\u00bb:~/repo/\u00abclient\u00bb::\u00abarchive\u00bb /path/to/file","title":"Backup a single file or directory"},{"location":"Backup/Borg.html#backup-an-entire-filesystem","text":"Source: thomas-leistner.de Locations you want to exclude: 1 2 3 4 5 6 7 8 /dev /lost+found /mnt /media /proc /run /sys /tmp 1 2 3 4 5 6 7 8 9 10 11 # borg create --progress --verbose --stats --exclude-caches --exclude '/dev/*' \\ --exclude '/lost+found/*' \\ --exclude '/mnt/*' \\ --exclude '/media/*' \\ --exclude '/proc/*' \\ --exclude '/run/*' \\ --exclude '/sys/*' \\ --exclude '/tmp/*' \\ --exclude re:/ \\\\ .cache/ \\ --exclude re:/ \\\\ .ccache/ \\ borg@\u00abserver\u00bb:~/repo/\u00abclient\u00bb::\u00abclient\u00bb-\u00abdate\u00bb /","title":"Backup an entire filesystem"},{"location":"Backup/Borg.html#restore-a-backup","text":"","title":"Restore a backup"},{"location":"Backup/Borg.html#delete-an-archive","text":"1 # borg delete borg@\u00abserver\u00bb:~/repo/\u00abclient\u00bb::\u00abarchive\u00bb","title":"Delete an archive"},{"location":"Backup/Borg.html#delete-old-archives","text":"1 2 3 4 5 6 # borg prune --verbose --stats --progress --list \\ --keep-daily = 14 \\ --keep-weekly = 8 \\ --keep-monthly = 12 \\ --keep-yearly = 10 \\ borg@\u00abserver\u00bb:~/repo/\u00abclient\u00bb","title":"Delete old archives"},{"location":"Backup/Borg.html#automating-daily-backup","text":"Source: www.thomas-krenn.com","title":"Automating daily backup"},{"location":"Miscellaneous/Dotfiles.html","text":"Dotfiles \u00b6","title":"Dotfiles"},{"location":"Miscellaneous/Dotfiles.html#dotfiles","text":"","title":"Dotfiles"},{"location":"Miscellaneous/LUKS_Disk_Encryption.html","text":"LUKS Crypt \u00b6 Source: gist.github.com In this guide, I'm going to setup a keyfile or password-encrypted LUKS partition. I will be using a single, max-size partition on a single physical device. The mountpoint can be determined by running lsblk . Partition the physical device \u00b6 1 2 3 4 # parted /dev/sdX (parted) mklabel gpt (parted) mkpart primary 1 -1 (parted) quit Create the key file (optional) \u00b6 Before we go further, let's create our 2048-bit key file first. I'm going to install it /root/backup.key 1 2 # dd if = /dev/urandom of = /root/backup.key bs = 1024 count = 2 # chmod 0400 /root/backup.key Create LUKS partition \u00b6 In my case, /dev/sdX1 was created by parted . Create the LUKS partition with our key file or password now. With key file \u00b6 1 # cryptsetup luksFormat /dev/sdX1 /root/backup.key Associating our key with the LUKS partition will allow us to automount it later and prevent us from ever seeing a password prompt. 1 # cryptsetup luksAddKey /dev/sdX1 /root/backup.key --key-file = /root/backup.key With password \u00b6 1 # cryptsetup luksFormat --type luks2 /dev/sdX1 Initialize the LUKS partition \u00b6 With keyfile \u00b6 Before we can start using our LUKS partition, we have to size it properly and format it first. In order to do that, we will first use luksOpen which creates an IO backing device that allows us to interact with the partition. I'll call my device backup ; you can call yours whatever you want. 1 # cryptsetup luksOpen /dev/sdX1 backup --key-file = /root/backup.key The LUKS mapping device will now be available at /dev/mapper/backup With password \u00b6 To gain access to the encrypted partition, unlock it with the device mapper, using: 1 # cryptsetup open /dev/sdX1 backup Size the LUKS partition \u00b6 When using resize without any additional vars, it will use the max size of the underlying partition. 1 # cryptsetup resize backup Format the LUKS partition \u00b6 I'm going to use ext4 ; you can use whatever you want. 1 # mkfs.ext4 /dev/mapper/backup Create a mount point \u00b6 I'll create a mount point at /backup 1 2 # mkdir -p /backup # chmod 755 /backup Mount the LUKS mapping device \u00b6 1 2 # cryptsetup open /dev/sdX1 backup # mount /dev/mapper/backup /backup To check the status, use: 1 $ df /backup Unmount the LUKS mapping device \u00b6 1 2 # unmount /backup # cryptsetup close backup Automountable \u00b6 With keyfile \u00b6 To avoid the hassle of mounting are encrypted volume manually, we can set it up such that it automounts using the specified key file. First you have to get the UUID for your partition. 1 $ ls -l /dev/disk/by-uuid Find the UUID that links to your disk. It has the format xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx . 1 2 # export UUID = \"xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\" # echo \"backup UUID= ${ UUID } /root/backup.key luks\" >> /etc/crypttab Finally, specify the automount 1 # echo \"/dev/mapper/backup /backup auto\" >> /etc/fstab With password \u00b6 1 # echo \"/dev/mapper/backup /backup auto defaults,errors=remount-ro 0 2\" >> /etc/fstab Mount stuff! 1 # mount -a","title":"LUKS Disk Encryption"},{"location":"Miscellaneous/LUKS_Disk_Encryption.html#luks-crypt","text":"Source: gist.github.com In this guide, I'm going to setup a keyfile or password-encrypted LUKS partition. I will be using a single, max-size partition on a single physical device. The mountpoint can be determined by running lsblk .","title":"LUKS Crypt"},{"location":"Miscellaneous/LUKS_Disk_Encryption.html#partition-the-physical-device","text":"1 2 3 4 # parted /dev/sdX (parted) mklabel gpt (parted) mkpart primary 1 -1 (parted) quit","title":"Partition the physical device"},{"location":"Miscellaneous/LUKS_Disk_Encryption.html#create-the-key-file-optional","text":"Before we go further, let's create our 2048-bit key file first. I'm going to install it /root/backup.key 1 2 # dd if = /dev/urandom of = /root/backup.key bs = 1024 count = 2 # chmod 0400 /root/backup.key","title":"Create the key file (optional)"},{"location":"Miscellaneous/LUKS_Disk_Encryption.html#create-luks-partition","text":"In my case, /dev/sdX1 was created by parted . Create the LUKS partition with our key file or password now.","title":"Create LUKS partition"},{"location":"Miscellaneous/LUKS_Disk_Encryption.html#with-key-file","text":"1 # cryptsetup luksFormat /dev/sdX1 /root/backup.key Associating our key with the LUKS partition will allow us to automount it later and prevent us from ever seeing a password prompt. 1 # cryptsetup luksAddKey /dev/sdX1 /root/backup.key --key-file = /root/backup.key","title":"With key file"},{"location":"Miscellaneous/LUKS_Disk_Encryption.html#with-password","text":"1 # cryptsetup luksFormat --type luks2 /dev/sdX1","title":"With password"},{"location":"Miscellaneous/LUKS_Disk_Encryption.html#initialize-the-luks-partition","text":"","title":"Initialize the LUKS partition"},{"location":"Miscellaneous/LUKS_Disk_Encryption.html#with-keyfile","text":"Before we can start using our LUKS partition, we have to size it properly and format it first. In order to do that, we will first use luksOpen which creates an IO backing device that allows us to interact with the partition. I'll call my device backup ; you can call yours whatever you want. 1 # cryptsetup luksOpen /dev/sdX1 backup --key-file = /root/backup.key The LUKS mapping device will now be available at /dev/mapper/backup","title":"With keyfile"},{"location":"Miscellaneous/LUKS_Disk_Encryption.html#with-password_1","text":"To gain access to the encrypted partition, unlock it with the device mapper, using: 1 # cryptsetup open /dev/sdX1 backup","title":"With password"},{"location":"Miscellaneous/LUKS_Disk_Encryption.html#size-the-luks-partition","text":"When using resize without any additional vars, it will use the max size of the underlying partition. 1 # cryptsetup resize backup","title":"Size the LUKS partition"},{"location":"Miscellaneous/LUKS_Disk_Encryption.html#format-the-luks-partition","text":"I'm going to use ext4 ; you can use whatever you want. 1 # mkfs.ext4 /dev/mapper/backup","title":"Format the LUKS partition"},{"location":"Miscellaneous/LUKS_Disk_Encryption.html#create-a-mount-point","text":"I'll create a mount point at /backup 1 2 # mkdir -p /backup # chmod 755 /backup","title":"Create a mount point"},{"location":"Miscellaneous/LUKS_Disk_Encryption.html#mount-the-luks-mapping-device","text":"1 2 # cryptsetup open /dev/sdX1 backup # mount /dev/mapper/backup /backup To check the status, use: 1 $ df /backup","title":"Mount the LUKS mapping device"},{"location":"Miscellaneous/LUKS_Disk_Encryption.html#unmount-the-luks-mapping-device","text":"1 2 # unmount /backup # cryptsetup close backup","title":"Unmount the LUKS mapping device"},{"location":"Miscellaneous/LUKS_Disk_Encryption.html#automountable","text":"","title":"Automountable"},{"location":"Miscellaneous/LUKS_Disk_Encryption.html#with-keyfile_1","text":"To avoid the hassle of mounting are encrypted volume manually, we can set it up such that it automounts using the specified key file. First you have to get the UUID for your partition. 1 $ ls -l /dev/disk/by-uuid Find the UUID that links to your disk. It has the format xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx . 1 2 # export UUID = \"xxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\" # echo \"backup UUID= ${ UUID } /root/backup.key luks\" >> /etc/crypttab Finally, specify the automount 1 # echo \"/dev/mapper/backup /backup auto\" >> /etc/fstab","title":"With keyfile"},{"location":"Miscellaneous/LUKS_Disk_Encryption.html#with-password_2","text":"1 # echo \"/dev/mapper/backup /backup auto defaults,errors=remount-ro 0 2\" >> /etc/fstab Mount stuff! 1 # mount -a","title":"With password"},{"location":"Raspberry_Pi/Headless_Setup.html","text":"Raspberry Pi Headless Setup \u00b6 Source: www.raspberrypi.org This guide describes the installation of Raspbian on a Raspberry Pi 3B+ as a headless server. Download Raspbian Image \u00b6 The latest Raspbian image can be downloaded from https://www.raspberrypi.org/downloads/raspbian/ . In this case no desktop environment is needed so we use Raspbian Stretch Lite . Extract the zip file by running the following command with adjusted date: 1 2 $ unzip 2018 -11-13-raspbian-stretch-lite.zip $ rm 2018 -11-13-raspbian-stretch-lite.zip Write the image to the SD card \u00b6 Run lsblk before and after inserting the SD card into the SD card reader in order to determine the NAME of the SD card. The device should be listed as sdX where X is a lower-case letter indicating the device. If any partitions on the SD card are currently mounted (check the rightmost column of lsblk ), unmount all of them. 1 $ umount /dev/sdX1 Write the image to the SD card with dd . if= specifies the image as the source file and of= specifies the SD card as the destination. Make sure to use the correct device to avoid data loss. The destination is specified by device name, not by partition name. 1 # dd bs = 4M if = 2018 -11-13-raspbian-stretch-lite.img of = /dev/sdX status = progress conv = fsync If any errors occur, try block size 1M instead of 4M Optional: Checking whether the image was written correctly \u00b6 The output of the dd command shows a number of written records ( xxx+0 records in ). Use this record count to copy the image back from the SD card to your local drive. 1 # dd bs = 4M if = /dev/sdX of = from-sd-card.img status = progress count = xxx Truncate the new image to the size of the original image and compare the new image with the original one. 1 2 # truncate --reference 2018 -11-13-raspbian-stretch-lite.img from-sd-card.img $ diff -s from-sd-card.img 2018 -11-13-raspbian-stretch-lite.img Eject the SD card \u00b6 Flush the write cache. 1 $ sync Remove the SD card from the card reader. Enable ssh for headless systems \u00b6 Insert the SD card into the card reader. It will be mounted by defalt. Navigate to the boot partition of the SD card and create an empty file named ssh . The mountpoint of the boot partition can be determined via lsblk . 1 2 cd /run/media/$USER/boot touch ssh Enable WIFI for headless systems \u00b6 Source: raspberrypi.stackexchange.com Insert the SD card into the card reader. It will be mounted by defalt. Navigate to the boot partition of the SD card. The mountpoint of the boot partition can be determined via lsblk . 1 $ cd /run/media/ $USER /boot Create a file named wpa_supplicant.conf with the following content: 1 2 3 4 5 6 7 8 9 ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 country=\u00abyour_ISO-3166-1_two-letter_country_code\u00bb network={ ssid=\"\u00abyour_SSID\u00bb\" psk=\"\u00abyour_PSK\u00bb\" key_mgmt=WPA-PSK } Replace \u00abyour_ISO-3166-1_two-letter_country_code\u00bb with your ISO Country Code , \u00abyour_SSID\u00bb with the SSID of your network and \u00abyour_PSK\u00bb with the corresponding wifi password. Connect to the Raspberry Pi \u00b6 Source: hackernoon.com Establish an ssh connection to the Raspberry Pi with default credentials: 1 2 User: pi Password: raspberry 1 $ ssh pi@raspberrypi If this does not initialize a connection, find out the IP either by running nmap -p 22 \u00absubnet mask\u00bb on your local subnet or finding the device in the router's DHCP table. You can now change the host name if you want. Replace raspberrypi by the new name in the following two files and reboot. 1 2 3 # vim /etc/hostname # vim /etc/hosts # reboot Remove the message of the day 1 # echo \"\" > /etc/motd Secure login and permissions \u00b6 If needed, configure the Raspberry Pi via the configuration script. 1 # raspi-config Change the default root password. 1 # passwd root Now create a new user for ssh access and allow sudo access for the new account. Don't remove sudo access for pi immediately. You can remove it once you have tested sudo with the new user account. 1 2 # adduser \u00abuser\u00bb # usermod -a -G sudo \u00abuser\u00bb If you have sudo access with your new account, remove the default user pi. 1 # deluser -remove-home pi For further ssh setup instructions visit Securing SSH Guide","title":"Headless Setup"},{"location":"Raspberry_Pi/Headless_Setup.html#raspberry-pi-headless-setup","text":"Source: www.raspberrypi.org This guide describes the installation of Raspbian on a Raspberry Pi 3B+ as a headless server.","title":"Raspberry Pi Headless Setup"},{"location":"Raspberry_Pi/Headless_Setup.html#download-raspbian-image","text":"The latest Raspbian image can be downloaded from https://www.raspberrypi.org/downloads/raspbian/ . In this case no desktop environment is needed so we use Raspbian Stretch Lite . Extract the zip file by running the following command with adjusted date: 1 2 $ unzip 2018 -11-13-raspbian-stretch-lite.zip $ rm 2018 -11-13-raspbian-stretch-lite.zip","title":"Download Raspbian Image"},{"location":"Raspberry_Pi/Headless_Setup.html#write-the-image-to-the-sd-card","text":"Run lsblk before and after inserting the SD card into the SD card reader in order to determine the NAME of the SD card. The device should be listed as sdX where X is a lower-case letter indicating the device. If any partitions on the SD card are currently mounted (check the rightmost column of lsblk ), unmount all of them. 1 $ umount /dev/sdX1 Write the image to the SD card with dd . if= specifies the image as the source file and of= specifies the SD card as the destination. Make sure to use the correct device to avoid data loss. The destination is specified by device name, not by partition name. 1 # dd bs = 4M if = 2018 -11-13-raspbian-stretch-lite.img of = /dev/sdX status = progress conv = fsync If any errors occur, try block size 1M instead of 4M","title":"Write the image to the SD card"},{"location":"Raspberry_Pi/Headless_Setup.html#optional-checking-whether-the-image-was-written-correctly","text":"The output of the dd command shows a number of written records ( xxx+0 records in ). Use this record count to copy the image back from the SD card to your local drive. 1 # dd bs = 4M if = /dev/sdX of = from-sd-card.img status = progress count = xxx Truncate the new image to the size of the original image and compare the new image with the original one. 1 2 # truncate --reference 2018 -11-13-raspbian-stretch-lite.img from-sd-card.img $ diff -s from-sd-card.img 2018 -11-13-raspbian-stretch-lite.img","title":"Optional: Checking whether the image was written correctly"},{"location":"Raspberry_Pi/Headless_Setup.html#eject-the-sd-card","text":"Flush the write cache. 1 $ sync Remove the SD card from the card reader.","title":"Eject the SD card"},{"location":"Raspberry_Pi/Headless_Setup.html#enable-ssh-for-headless-systems","text":"Insert the SD card into the card reader. It will be mounted by defalt. Navigate to the boot partition of the SD card and create an empty file named ssh . The mountpoint of the boot partition can be determined via lsblk . 1 2 cd /run/media/$USER/boot touch ssh","title":"Enable ssh for headless systems"},{"location":"Raspberry_Pi/Headless_Setup.html#enable-wifi-for-headless-systems","text":"Source: raspberrypi.stackexchange.com Insert the SD card into the card reader. It will be mounted by defalt. Navigate to the boot partition of the SD card. The mountpoint of the boot partition can be determined via lsblk . 1 $ cd /run/media/ $USER /boot Create a file named wpa_supplicant.conf with the following content: 1 2 3 4 5 6 7 8 9 ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev update_config=1 country=\u00abyour_ISO-3166-1_two-letter_country_code\u00bb network={ ssid=\"\u00abyour_SSID\u00bb\" psk=\"\u00abyour_PSK\u00bb\" key_mgmt=WPA-PSK } Replace \u00abyour_ISO-3166-1_two-letter_country_code\u00bb with your ISO Country Code , \u00abyour_SSID\u00bb with the SSID of your network and \u00abyour_PSK\u00bb with the corresponding wifi password.","title":"Enable WIFI for headless systems"},{"location":"Raspberry_Pi/Headless_Setup.html#connect-to-the-raspberry-pi","text":"Source: hackernoon.com Establish an ssh connection to the Raspberry Pi with default credentials: 1 2 User: pi Password: raspberry 1 $ ssh pi@raspberrypi If this does not initialize a connection, find out the IP either by running nmap -p 22 \u00absubnet mask\u00bb on your local subnet or finding the device in the router's DHCP table. You can now change the host name if you want. Replace raspberrypi by the new name in the following two files and reboot. 1 2 3 # vim /etc/hostname # vim /etc/hosts # reboot Remove the message of the day 1 # echo \"\" > /etc/motd","title":"Connect to the Raspberry Pi"},{"location":"Raspberry_Pi/Headless_Setup.html#secure-login-and-permissions","text":"If needed, configure the Raspberry Pi via the configuration script. 1 # raspi-config Change the default root password. 1 # passwd root Now create a new user for ssh access and allow sudo access for the new account. Don't remove sudo access for pi immediately. You can remove it once you have tested sudo with the new user account. 1 2 # adduser \u00abuser\u00bb # usermod -a -G sudo \u00abuser\u00bb If you have sudo access with your new account, remove the default user pi. 1 # deluser -remove-home pi For further ssh setup instructions visit Securing SSH Guide","title":"Secure login and permissions"},{"location":"Raspberry_Pi/OpenVPN.html","text":"OpenVPN on a Raspberry Pi \u00b6 Source: www.kuketz-blog.de Create an openvpn user \u00b6 To avoid conflicts with other users, create a new user for the VPN service and set a password for this user. In my case the user is called \u00abopenvpn\u00bb. 1 2 3 4 5 6 # adduser \u00abopenvpn\u00bb # passwd \u00abopenvpn\u00bb # sudo usermod -a -G sudo \u00abopenvpn\u00bb # mkdir /home/\u00abopenvpn\u00bb # chown /home/openvpn \u00abopenvpn\u00bb # chgrp /home/openvpn \u00abopenvpn\u00bb Log in as \u00abopenvpn\u00bb. 1 $ su - \u00abopenvpn\u00bb Run the PiVPN install script \u00b6 1 2 $ curl -L install.pivpn.io > pivpn.sh $ chmod +x pivpn.sh Once you are sure the script is not harmful in any way, run the installation script. 1 $ ./pivpn.sh Confirm the current network settings and make sure the shown IP address (eg. 192.168.2.110) is always assigned to this device by the router. Choose the user \u00abopenvpn\u00bb. When asked, select UDP as a protocol. Confirm the default OpenVPN port 1194. Select ECDSA encryption strength. (Recommended: 256-bit) If you use DNS, enter the domain name. Reboot after the installation has finished Add clients \u00b6 To generate a client configuration, use: 1 $ pivpn add Select a different username and password for each client. Copy the resulting ovpn file to your client device via scp and use it in your OpenVPN client.","title":"OpenVPN"},{"location":"Raspberry_Pi/OpenVPN.html#openvpn-on-a-raspberry-pi","text":"Source: www.kuketz-blog.de","title":"OpenVPN on a Raspberry Pi"},{"location":"Raspberry_Pi/OpenVPN.html#create-an-openvpn-user","text":"To avoid conflicts with other users, create a new user for the VPN service and set a password for this user. In my case the user is called \u00abopenvpn\u00bb. 1 2 3 4 5 6 # adduser \u00abopenvpn\u00bb # passwd \u00abopenvpn\u00bb # sudo usermod -a -G sudo \u00abopenvpn\u00bb # mkdir /home/\u00abopenvpn\u00bb # chown /home/openvpn \u00abopenvpn\u00bb # chgrp /home/openvpn \u00abopenvpn\u00bb Log in as \u00abopenvpn\u00bb. 1 $ su - \u00abopenvpn\u00bb","title":"Create an openvpn user"},{"location":"Raspberry_Pi/OpenVPN.html#run-the-pivpn-install-script","text":"1 2 $ curl -L install.pivpn.io > pivpn.sh $ chmod +x pivpn.sh Once you are sure the script is not harmful in any way, run the installation script. 1 $ ./pivpn.sh Confirm the current network settings and make sure the shown IP address (eg. 192.168.2.110) is always assigned to this device by the router. Choose the user \u00abopenvpn\u00bb. When asked, select UDP as a protocol. Confirm the default OpenVPN port 1194. Select ECDSA encryption strength. (Recommended: 256-bit) If you use DNS, enter the domain name. Reboot after the installation has finished","title":"Run the PiVPN install script"},{"location":"Raspberry_Pi/OpenVPN.html#add-clients","text":"To generate a client configuration, use: 1 $ pivpn add Select a different username and password for each client. Copy the resulting ovpn file to your client device via scp and use it in your OpenVPN client.","title":"Add clients"},{"location":"Troubleshooting/Arduino.html","text":"Arduino Troubleshooting \u00b6 libtinfo.so.5 \u00b6 Source: github.com , www.dinotools.de It seems to be a known issue with Arduino software on Arch Linux: When trying to load any program to a microcontroller, the following error emerges: 1 error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory According to www.dinotools.de , the reason is that libtinfo.so.5 is not included in libcurses packages on Arch distributions. Therefore Arduino cannot find the library where it expects it to be. A simple (but dirty) approach to solve the problem is to create a link to libtinfo.so.5 which exists on my system. 1 # ln -s /lib/libtinfo.so.6 /lib/libtinfo.so.5 Others suggest linking to various libncurses.so files which I haven't tested yet.","title":"Arduino"},{"location":"Troubleshooting/Arduino.html#arduino-troubleshooting","text":"","title":"Arduino Troubleshooting"},{"location":"Troubleshooting/Arduino.html#libtinfoso5","text":"Source: github.com , www.dinotools.de It seems to be a known issue with Arduino software on Arch Linux: When trying to load any program to a microcontroller, the following error emerges: 1 error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory According to www.dinotools.de , the reason is that libtinfo.so.5 is not included in libcurses packages on Arch distributions. Therefore Arduino cannot find the library where it expects it to be. A simple (but dirty) approach to solve the problem is to create a link to libtinfo.so.5 which exists on my system. 1 # ln -s /lib/libtinfo.so.6 /lib/libtinfo.so.5 Others suggest linking to various libncurses.so files which I haven't tested yet.","title":"libtinfo.so.5"},{"location":"Troubleshooting/Manjaro.html","text":"Manjaro Troubleshooting \u00b6 xbacklight not working \u00b6 Source: wiki.archlinux.org At some point in time, xbacklight stopped working for me. It accepts all valid inputs and terminates with exit code 0 without applying any of the given modifications to the system. This problem can be solved by putting the following lines into the file /etc/X11/xorg.conf.d/20-video.conf : /etc/X11/xorg.conf.d/20-video.conf 1 2 3 4 5 Section \"Device\" Identifier \"Intel Graphics\" Driver \"intel\" Option \"Backlight\" \"intel_backlight\" EndSection After rebooting, everything should work as expected.","title":"Manjaro"},{"location":"Troubleshooting/Manjaro.html#manjaro-troubleshooting","text":"","title":"Manjaro Troubleshooting"},{"location":"Troubleshooting/Manjaro.html#xbacklight-not-working","text":"Source: wiki.archlinux.org At some point in time, xbacklight stopped working for me. It accepts all valid inputs and terminates with exit code 0 without applying any of the given modifications to the system. This problem can be solved by putting the following lines into the file /etc/X11/xorg.conf.d/20-video.conf : /etc/X11/xorg.conf.d/20-video.conf 1 2 3 4 5 Section \"Device\" Identifier \"Intel Graphics\" Driver \"intel\" Option \"Backlight\" \"intel_backlight\" EndSection After rebooting, everything should work as expected.","title":"xbacklight not working"}]}